DONE list
=========
- Filtering
- Filtering with just one value per field
- sorting in header: '', 'asc', 'desc'
- check for datefields?
  example from / to : date 2 > than date 1 / date 1 < than date 2
  example birthday : date > today
  example death : date < today
  => DO IT LATER


QUESTION
========
- multiple sorting needed?
- multiple filtering needed?
- filtering chips?
- sorting chips?
- ChipMenuDialog: keep the icons as png?
  SpecialButtons: keep the icons as png?
  ButtonDialog: keep the icons as png?
- saving rows: what will the component receive after saving?
  all rows ? => all editing must be blocked
  only saved rows ? => how?
  when will the component know, when saving is finished
  asynchroneous: is the user allowed to change the page?


TODO list
=========

- EXCEL export excel with line break inside the cell?
  now I replace "\n" => " | " : value = value.replace("\n", " | ");
  put the text in parentesis
  problem with export to excel for multilines

- TEST numbers and decimal (decimal with letters?)

- testing error messsages with several lines

- test sorting columns

- rename : => export default function InselTableMenu

- column width resizing not possible when window too small? 
  column widths are resize when resizing the window => thus thir width maybe     smaller than the defined min width

- resizer: on lines i removed the hover color
  do the same in the header

- TODO : can we measure rect of a text (IButtonDialog)

- test: filtering

- Warning: Each child in a list should have a unique “key” prop.
  Why this message when a key is defined?

- TEST: Block edited rows while saving


----------------------------------------------

Files done
==========
Done until IHeaderManage.js


/////////////////////////////////////////////
23.12.2024


- Sorting export function with ou a class?
missing export default

- Sorting doesnt work

          
      {/* main button dialog */}     
      {this.props.dialogName.length > 0 &&
        <EditDialog
          headers = {this.props.headers}
          row = {this.state.data[rowIndex]}
          setDataFromDialog = {this.props.setDataFromDialog(row)}
        >
        </EditDialog>
      }



//// TODO for 10.12.2024
//// TODO : integer anf float fields: make float not accept letters
// <TextField inputProps={{ type: 'number'}} />

import * as React from "react";
import { TextField } from "@mui/material";

export default function App() {
  const [phone, setPhone] = React.useState("123");
  const [info, setinfo] = React.useState();

  let focusedName = "";

  const handleEnter = (e) => {
    //focusedName = e.target.name;
    //setinfo(e.target.name);
  };

  const handleLeave = (e) => {
    //focusedName = "";
    //setinfo(" no fcusedName2");

    const val = e.target.value;
    const haspos = val.includes(".");
    if (haspos) {
      const form = (Math.round(val * 100) / 100).toFixed(2);
      setinfo(form);
    }

  };

  const handleChange = (event) => {
    //if (val.match(/[^0-9]./)) {
    //  return event.preventDefault();
    //}

    /*-
    if (info === event.target.id) {
    } else {
      const haspos = val.contains(".");
      if (haspos) {
        const pos = val.IndexOf(".");
        const p1 = val.substring(0, pos);
        const p2 = val.substring(pos + 1, val.length - pos);
      }
      // val.toFixed(3);
    }
    */
    const val = event.target.value;
    /*
    const haspos = val.includes(".");
    if (haspos) {
      const pos = val.indexOf(".");
      const p1 = val.substring(0, pos);
      const p2 = val.substring(pos + 1);
      //const p3 = p2.substring(0, 2);
      const p3 = Math.round(val * 20) / 20;
      //setinfo(p3);
      //const newval = p1 + "." + p2;
      //setPhone(newval);
      //return;
    }
    */

    setPhone(val);
  };

  return (
    <div>
      <TextField
        id="phone_number"
        name="name1"
        label="Phone Number"
        variant="outlined"
        type="number"
        inputProps={{ inputMode: "numeric" }}
        value={phone}
        onChange={(e) => handleChange(e)}
        onEnter={(e) => handleEnter(e)}
        onBlur={(e) => handleLeave(e)}
      />
      <TextField
        id="phone_number2"
        name="name2"
        label="Phone Number"
        variant="outlined"
        type="number"
        inputProps={{ inputMode: "numeric" }}
        //value={phone}
        //onChange={(e) => handleChange(e)}
        onEnter={(e) => handleEnter(e)}
        onBlur={(e) => handleLeave(e)}
      />
      <TextField value={info}></TextField>
    </div>
  );
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// 23.12.2024




/////////////////////////////////////////////////////////////////////
// implement savingInProgressAll
// ITable
// const mainButtonsDisabled = this.state.mainButtonsDisabled;
const savingInProgressAll = this.state.savingInProgressAll;
// <Tooltip title="Ctrl-S" arrow> =>
disabled={mainButtonsDisabled || savingInProgressAll}
// <Tooltip title="Ctrl-U" arrow></Tooltip>
disabled={mainButtonsDisabled || savingInProgressAll}
// return( <ITableRow
savingInProgressAll={this.state.savingInProgressAll}

// ITableRow
// rename resiszigInAction => resizingInAction
// constructor(props) => 
const {
  settings,
  headers,
  rowInfoList,
  rowInfoIndex,
  primaryKey,
  savingInProgressAll,
  oldRow,
  row
} = this.props;
// <IFieldText and others=>
  editing={editing && !savingInProgressAll}
//  <IFieldRowEditButton
editing={editing}
savingInProgressAll={savingInProgressAll}

/////////////////////////////////////////////////
// IFieldRowEditButton.js
let disabled = true;
if (!savingInProgressAll)
{
 
  if (editType === IConst.editType_ButtonEditRow ||
    editType === IConst.editType_ButtonEdit)
  {
    disabled = false;
  }
  else if (editType === IConst.editType_ButtonSave ||
    editType === IConst.editType_ButtonUndo)
  {
    disabled = !isChanged;
  }    
  else if (editType === IConst.editType_ButtonDelete)
  {
    disabled = isDeleted && rowState !== IConst.rowStateInserted;
  }      
}
/// delete => 
const icon = 

//////////////////////////////////////////////////
// ITableCellWidthResizer.js
// delete => SortColumn = () =>
// replace all => return (
      <TableCell className={classes.table_head_cell} >
        <Grid 
          container 
          style={{ 
            height: height, 
            borderBottomColor: 'black',
            borderBottomStyle: 'solid',
            borderBottomWidth: '1px',
            padding: '0px',
          }}>

          {hasHeaderMenu && this.props.headerHorizontalAlign === IConst.horizontalAlign_Right &&
          <Grid item style={{ 
            width: '25px', 
            display: 'flex', 
            justifyContent: 'flex_end', 
            alignItems: verticalAlign, }}>
            <ITableMenu
              headers={this.props.headers}
              headerIndex={headerIndex}
              HideColumn={() => this.props.HideColumn(headerIndex)}
              SortColumn={(sorting) => this.SortColumn(sorting, true)}
              FilterColumn={() => this.props.FilterColumn(headerIndex)}
            ></ITableMenu>
          </Grid>}

          {isSortable && this.props.headerHorizontalAlign === IConst.horizontalAlign_Right &&
          <Grid item style={{
            display: 'flex',
            justifyContent: 'flex_end', 
            alignItems: verticalAlign, 
            width: '25px',
            // TODO padding: '0px',
          }}>
            <IconButton 
              stlye={{ borderRadius: '3px' }}
              onClick = {(sorting) => this.SortColumn(sorting, false)}>
              {isSortedAscending && <NorthIcon/>}
              {!isSortedAscending && <SouthIcon/>}
            </IconButton>
          </Grid>}

          <Grid item style={{
            display: 'flex',
            justifyContent: horizontalAlign, 
            alignItems: verticalAlign, 
            // TODO textAlign: 'left',
            flex: 1,
            padding: '5px',
          }}>
            {children}
          </Grid>

          {isSortable && this.props.headerHorizontalAlign !== IConst.horizontalAlign_Right &&
          <Grid item style={{
            display: 'flex',
            justifyContent: 'flex_start', 
            alignItems: verticalAlign, 
            textAlign: 'left',
            width: '25px',
            padding: '0px',
          }}>
            <IconButton 
              stlye={{ borderRadius: '3px' }}
              onClick = {(sorting) => this.SortColumn(sorting, false)}>
              {isSortedAscending && <NorthIcon/>}
              {!isSortedAscending && <SouthIcon/>}
            </IconButton>
          </Grid>}

          {hasHeaderMenu && this.props.headerHorizontalAlign !== IConst.horizontalAlign_Right && 
          <Grid item style={{
            display: 'flex',
            justifyContent: 'flex-start', 
            alignItems: verticalAlign, 
            textAlign: 'left',
            width: '25px',
            padding: '0px',
          }}>
            <ITableMenu
              headers={this.props.headers}
              headerIndex={headerIndex}
              HideColumn={() => this.props.HideColumn(headerIndex)}
              SortColumn={(sorting) => this.SortColumn(sorting, true)}
              FilterColumn={() => this.props.FilterColumn(headerIndex)}
              ></ITableMenu>
          </Grid>}

          {(!notResizable) &&
          <Grid item ><div 
            className={classes.resizerEW}
            onMouseDown={(e) => this.props.handleMouseDownRowEW(e, headerIndex)} 
          >&nbsp;</div></Grid>}          
        </Grid>
      </TableCell>
        


/////////////////////////////////
//////////////////////////////////////////////////////
////////////////////////////////////////////////
// App.js
// test for valueGetter =>
/*
  {
    id: 23,
    databaseField: "",
    headerTitle: "Getter",
    isResizable: true,
    isEditable: false,
    isRequired: false,
    isVisible: true,
    isSortable: true,
    defaultSorting: '',
    width: 120,
    minWidth: 100,
    maxWidth: 300,
    editType: 'getter',
    defaultValue: '',
    dataFieldName: '',
    horizontalAlign: 'left',
    hasHeaderMenu: true,
    valueGetter: ({ data }) => `${data.lastName} ${data.firstName}`    
  },


valueGetter: (params) => {
        // Example: Concatenate first and last names to create a full name
        return `${params.data.firstName} ${params.data.lastName}`;  
*/

/////////////////////////////////////////////////////////////////////
// columns not resizing: check bug

/////////////////////////////////////////////////////////////////////
// header resizer: remove hover color





//////////////////////////////////////////////////
// new heeder definition for date
// datetimeCheck: 1 // date not before today
// datetimeCheck: 2 // date not after today
// datetimeCheck: 3 // date not after field "xyz"
// datetimeCheck: 4 // date not before field "xyz"
// datetimeCheckField: "xyz" // date field "xyz" for checks 3 and 4 


// example: to from ... to ... : field1 ... field2
// header field1 : 
//    datetimeCheck: 3, 
//    datetimeCheckField: "field2" ,
// header field2 : 
//    datetimeCheck: 4, 
//    datetimeCheckField: "field1" ,
// check: Utils.js => hasError =>

//    if (!datetimeCheck) return false;
//    if (datetimeCheck === 1 && value < new Date() ) return true;
//    if (datetimeCheck === 2 && value > new Date() ) return true;
//    if (datetimeCheck === 3 {
//      if (!datetimeCheckField) return false;
//      const tmp = row[datetimeCheckField];
//      if (value > tmp) return true;
//    }
//    if (datetimeCheck === 4 {
//      if (!datetimeCheckField) return false;
//      const tmp = row[datetimeCheckField];
//      if (value < tmp) return true;
//    }
//    return false;  

//////////////////
//    headers for test datetim from...to =>
  const tmp = { 
    id: 23,
    headerTitle: " Date From",
    helperText: "not after 'Date To'",
    isResizable: true,
    isEditable: true,
    isVisible: true,
    isSortable: true,
    width: 120,
    minWidth: 100,
    maxWidth: 320,
    editType: 'date',
    dataFieldName: 'datefrom',
    datetimeCheck: 3,
    datetimeCheckField: "dateto",
    datetimeCheckDifference: 5,
    horizontalAlign: 'center',
    hasHeaderMenu: true,
};

const tmp2 = { 
  id: 24,
  headerTitle: "Date To",
  helperText: "not before 'Date From'",
  isResizable: true,
  isEditable: true,
  isVisible: true,
  isSortable: true,
  width: 120,
  minWidth: 100,
  maxWidth: 320,
  editType: 'date',
  dataFieldName: 'dateto',
  datetimeCheck: 4,
  datetimeCheckField: "datefrom",
  datetimeCheckDifference: 10,
  horizontalAlign: 'center',
  hasHeaderMenu: true,
};

///////// 
// creating data: =>
/*
  datefrom: randomUpdate,
  dateto: randomUpdate + 10,
*/

//////////////////////////////////////////
/// iTabeleRow

handleDataChange(value, field)
{
// change the row values and update row color and main buttons
const newRow = this.state.row;
newRow[field] = value;
this.setNewRowState_Edit()

// TODO : missing update state

// if datetime check for dates from...to
const hIndex = headers.findIndex(h => h.dataFieldName === field);
if (hIndex !== -1)
{
  if (headers[hIndex].editType === IConst.editType_Date &&
    (headers[hIndex].datetimeCheck === 3 || headers[hIndex].datetimeCheck === 4))
  {
    const otherField = headers[hIndex].datetimeCheckField;
    const dateTo = newRow[otherField];
    const dayiff = headers[hIndex].datetimeCheckDifference;
    const diffMiliSec = dayiff * 24 * 60 * 60 * 1000;
    if (headers[hIndex].datetimeCheck === 3 )
    {
      // here we check, that the new date is not bigger than the DateTo value
      const newdate = new Date(value.getTime() + diffMiliSec);
      if (value > dateTo) newRow[headers[hIndex].datetimeCheckField] = newdate;
    }
    else
    {
      // here we check, that the new date is not smaller than the DateFrom value
      const newdate = new Date(value.getTime() - diffMiliSec);
      if (value > dateFrom) newRow[headers[hIndex].datetimeCheckField] = newdate;
    }
  }
}

this.props.setMainButtonState();
}


/////////////////////////////////////////////
///////////////////////////////////////////////////
////////////////////////////////////////////
/////////////////////////////////////////////
///////////////////////////////////
// test headers getters =>
/*
  {
    id: "5",
    dataFieldName: "fullname",
    editType: "getter",
    getter: "`${row.lastName}, ${row.firstName}`",
  },  
  */


  ///////////////
  // iCellWidthResizer

  /*
    const isSortable = headers[headerIndex].isSortable;
    const isSortedAscending = headers[headerIndex].defaultSorting === IConst.sortingASC;
    const isSortedDescending = headers[headerIndex].defaultSorting === IConst.sortingDESC;
    const isUnsorted = headers[headerIndex].defaultSorting === '';


import QuestionMarkIcon from '@mui/icons-material/QuestionMark';    

    {isSortedAscending && <SwapVertIcon/>}
    {isSortedDescending && <SwapVertIcon  sx={{ transform: 'scaleX(-1)' }}/>}
    {isUnsorted && <QuestionMarkIcon/>}

/// CHANGE

///////////// in menu : 
 SortColumn = (newvalue, true) 

///////////// in button : 
 SortColumn = (newvalue, false) 

///////////// in cellresizer : 
    SortColumn = (newvalue, calledFromMenu) =>
    {
      let newSort = '';
      if (calledFromMenu)
      {
        newSort = newvalue;
      } 
      else
      {
        const sort = this.props.header.defaultSorting;
        newSort = 
          sort === IConst.sortingASC ? IConst.sortingDESC :
          sort === IConst.sortingDESC ? '' :
          sort === '' ? IConst.sortingASC :
      }
      this.props.SortColumn(headerIndex, sort);
    }

add menu unsorted
select  put icon
import CheckOutlinedIcon from '@mui/icons-material/CheckOutlined';



/////////////////////////////////////////////////////////////////////////////
// ITable onMouseMoveRowEW => try it without setState of headers

// => ITabelCellWidthResizerEW =

  handleMouseDownRowEW(e)
  {
    // resizing column width
    const mouseStart = e.clientX;
    //const colindex = index;
    const cellWidth = this.props.headers[headerIndex].width;
    
    
    const element = e.target;
    const parentCell = e.target.parent.parent;
    alert("e.target.parent.parent.key")

    element.style.backgroundColor = IConst.colorResizerBackground;

    const onMouseMoveRowEW = (e) => 
    {
      const newwidth = e.clientX - mouseStart + cellWidth;
      if (newwidth > this.props.headers[headerIndex].maxWidth &&
          newwidth !== this.props.headers[headerIndex].maxWidth)
      {
        //const newList2 = this.state.headers;
        //newList2[colindex].width = this.state.headers[colindex].maxWidth;
        //this.setState({headers : newList2});
        this.props.headers[colindex].width = this.props.headers[headerIndex].maxWidth;
        parentCell.style.width = this.props.headers[headerIndex].maxWidth;

      }
      else
      if (newwidth < this.props.headers[headerIndex].minWidth &&
        newwidth !== this.props.headers[headerIndex].minWidth)
      {
        //const newList2 = this.state.headers;
        //newList2[colindex].width = this.state.headers[colindex].minWidth;
        //this.setState({headers : newList2});

        this.props.headers[colindex].width = this.props.headers[headerIndex].minWidth;
        parentCell.style.width = this.props.headers[headerIndex].minWidth;

      }
      else
      if (newwidth < this.props.headers[headerIndex].maxWidth &&
          newwidth > this.props.headers[headerIndex].minWidth)
      {
        //const newList2 = this.state.headers;
        //newList2[colindex].width = newwidth;
        //this.setState({headers : newList2});
        this.props.headers[colindex].width = newwidth;
        parentCell.style.width = newwidth;
      }
      else 
      {
        //console.log("onMouseUpRowEW no resizing possible");
      }
    }

    const onMouseUpRowEW = (e) => 
    {
      document.removeEventListener('mousemove', onMouseMoveRowEW);
      document.removeEventListener('mouseup', onMouseUpRowEW);
      document.body.style.userSelect = "auto"; 
      element.style.backgroundColor = 'transparent';

      //const newList2 = this.state.headers;
      //this.setState({headers : newList2});

    };    

    document.addEventListener('mousemove', onMouseMoveRowEW);
    document.addEventListener('mouseup', onMouseUpRowEW);    
    document.body.style.userSelect = "none";  
}

  const width = headers[headerIndex].width;

 <TableCell 
   className={classes.table_head_cell} 
   id="tablecell-${headerIndex}"
   width={width}>
 </TableCell>

 //////////////////////////////////////////////////////////////
 


/// check other buttons : => disabled={this.state.savingInProgressAll}
